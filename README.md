# Advanced-progressive-web-apps
*Creating a good Progressive Web App is not just about the user interface, but also about understanding the platform, what's possible, and how to make a proper integration with the operating system. In this course, Advanced Progressive Web Apps, you’ll learn to integrate your app with mobile and desktop operating systems at different levels. First, you’ll explore the app installation flow and how to improve it. Next, you’ll discover how to enhance the experience by understanding the app's lifecycle, how to execute code in the background, and how to manage the updates and new versions of your app. Finally, you’ll learn how to integrate with the operating system, including communication with other apps and the usage of hardware and sensors available. When you’re finished with this course, you’ll have the skills and knowledge of APIs, design patterns, and techniques needed to create a Progressive Web App with better integration with the platform where it's installed.*

Course Overview
Hi, my name is *Iradukunda Didier*. Welcome to my course, Advanced Progressive Web Apps. I am a mobile app and web developer, trainer, and author. Progressive web apps are a new challenge in platform for web developers. Our web app now runs out of the browser, integrated with an operating system. In this course, we're going to increase the user experience of our PWA by using available APIs and ability. Some of the major topics that we will cover include how to gather analytics about installation and usage, increase installation and update opportunities, understanding the lifecycle and how to execute code in the background, and how we can integrate with the platform and hardware. By the end of this course, you will know how to improve installation, reliability, and conversion, how to deal with background execution and app's lifecycle, the abilities available on PWAs to access hardware and sensors, and how to integrate to the platform as all the other apps in the system. Before beginning, you should be familiar with the PWA concepts, including service workers, _____, my courses, Progressive Web Apps: The Big Picture and Designing Progressive Web Apps, as a start. I hope you will join me on this trip to improve the experience of our PWAs with the Advanced Progressive Web Apps course, at Pluralsight.

# Installing the Application

[Installing the Application](https://github.com/supernover/Advanced-progressive-web-apps/tree/main/advanced-progressive-web-apps/02) Tutorial

Introduction
Advanced Progressive Web Apps, Installing the Application. In this module, we're going to review things that we can do to improve user experience while installing the app. We're going to start with an installation architecture review. You should understand how it works and all the different modes that we have available. We will see how to track installation for analytics, how to promote the installation from our own user interface, how to prioritize store apps over a browser installation, in case we have an app in the app store, and finally, we're going to see how to improve installation reliability on the iOS and iPadOS. So let's jump into the architecture review.

# Installation Architecture
Before improving our code, we need to understand the installation architecture. When a user is installing a PWA, there are typically two steps involved, installing the launcher icon and the app assets. The launcher icon will create a new entry in the launcher menu, start screen, or home screen following other native apps on that particular OS. Installing the launcher icon is what is typically known as installing the app. If I ask a user, did you install the app, typically we are talking about the icon. We have different ways to actually install the launcher icon of a PWA. The most typical scenario is to install the PWA from the browser, but we can also install the app from an enterprise system. So employees of a company, for example, can actually install PWA from an internal system. Also, we can install PWAs from different app stores, such as Google Play Store, iOS App Store or Microsoft Store. Talking about the browser, the most common scenario for PWAs, we can install a PWA from an infobar or web app banner. That's a user interface rendered by the browser that will invite the user to install the app. Also, some browsers will offer a badge. The badge is a little icon that typically appears in the URL bar, expressing the ability to install the app. The user can also use the menu of the browser to actually install the app or add the app to the home screen. Different browsers and different operating systems are using different icons and names in the menu for triggering the same installation procedure. And finally, we can have a PWA creating a custom user interface within the PWA to trigger the installation, such as a button, an internal menu item, or an invitation banner. Based on the installation pattern, the browser, and the host platform, so the operating system, we can end up with different launcher icon types, such as a shortcut. Also known as Web Clip, this is typically available only on mobile devices such as iOS or Android. This is not a native package. We are not actually creating an app in that that OS. It's like a bookmark in the home screen that will trigger a standalone PWA experience. On some platforms, we are going to have on autogenerated PWA launcher. This is a package that was created and signed by the browser, so it's actually a native app, but it's not created by the developer. It's generated automatically by the browser. And also we have a manual PWA launcher. In this case, the package is created and published by the developer. Let's review shortcuts, or Web Clips. It's only available when we are installing the PWA from the browser. But when we click on that icon, it will open the browser in a different mode, such as standalone or Minimal UI. It's not completely integrated with the host OS. So, for example, sometimes a shortcut won't appear in the applications menu or in the launcher, only in the home screen. There are some limitations compared with the other types, such as there is no way to detect if the icon is already installed or not. That means that multiple installations are actually possible, and we won't have URL capture. That means if the user receives an email or a WhatsApp message pointing to URL of that PWA, the browser will render that content and not the PWA. On iOS and iPadOS, these shortcuts are known as Web Clips. They can be installed only from Safari or through an Apple configuration file that's typically being used for enterprise distribution. The OS will remember it. That means that if you buy a new iPhone and you are recovering a backup from iCloud, you will also get your Web Clips, so your PWAs. Now let's jump into Android. These are known as home screen shortcuts. Firefox, Opera, Brave, Samsung Internet on non‑Samsung devices are actually using this technique, and also Google Chrome on some uncommon situations. The next possible type is the autogenerated PWA launcher. It's also only available from browser installation. But instead of creating a shortcut, it's actually installing a native package, a native app. That app is created and signed by the browser locally or in the cloud. The advantages over shortcuts is that we have singleton installations. That means if the user has already installed the app, it won't have the option to install it again. Only one instance of every PWA will be on that device. URL capture can be available. It depends on the OS, it depends on the browser, but because it's a native package, it can actually listen for the URL of the PWA within the OS. Some limitations are still there, such as there is no way to detect if it's installed. The OS and browser don't remember that installation, at least today, which means if you buy a new phone or if you format your device, that autogenerated PWA launcher won't appear again automatically. Users will need to go and install the app again. The best example of an autogenerated PWA launcher happens in Android with a WebAPK. A WebAPK is a cloud‑generated Android package. It's being created by Google Chrome if you're using any Android device, also Samsung Internet browser, only when that browser is being executed on a Samsung Android device. If you're installing PWAs from the Samsung Galaxy Store, WebAPK is also being used. And finally enterprise distribution of PWAs through Managed Google Play iframe will also use WebAPK. When we are talking about desktop, typically autogenerated PWA launchers will be created locally in the host OS. For example, Google Chrome and Microsoft Edge, the Chromium version, are actually using this technique. And the final type is a manual PWA launcher. In this case, it's going to be available only from app stores or enterprise distribution. Some limitations are that we have to deal with the store rules and requirements. And the advantages is that we will have singleton installations, URL capture can be available, it can be detected on some browsers so there is a JavaScript API that will let us know if the app is installed or not, and the store or the OS will remember the installation. So if you are recovering a backup on a new device, that app will appear. On Android you can go through the Google Play Store with Trusted Web Activity, a PWA, that's the technology that will let us publish PWAs in the Google Play Store. Managed Google Play iframe is also available for these launchers. On iOS and iPadOS you can go to the App Store using a Web View. On Windows you can publish your PWA in the Microsoft Store, creating a manual PWA launcher. And finally on KaiOS for feature phones, you can also go to the stores for KaiOS and JioPhone and distribute a manual PWA launcher. What happens after you install a PWA? On some platforms, navigation will be transferred to the standalone app. So the current navigation context will continue in the app. That happens, for example, on desktop. On mobile, typically, navigation will continue in the browser. And if the user wants to open the PWA in standalone mode, she'd have to open that icon manually, and navigation would start from scratch. That was all for the app launcher icon. But the app is not just the icon. We also have assets. In this case, the installation will download and save all the necessary resources to render the app on every network situation. To do that, we have a web runtime and a web server. We know that the first time we are accessing the URL, a web page is being downloaded from the web server, but also we are going to register a service worker. The service worker will be installed in the web runtime, and the service worker will download more assets, such as JavaScript files and another web resources. When everything is in the client, we have a local cache, and that's basically when the app assets installation happens. App assets and shortcut icon installation happen independently. That means you can actually have partial installations, such as a launcher icon with no app assets or app assets without a launcher icon. In fact, the web app manifest scope and the service worker scope can be different. As a summary for installation architecture, we have icon installation and app assets installation. There are many types of icon installation, browser, autogenerated, PWA launcher, and a manual PWA launcher. App assets are actually the ones that are being installed by the service worker.

# Track PWA Installation for Analytics
When you deploy your PWA to the market, you typically want to know how many users are installing your PWA. So we're going to track PWA installations for analytics. To measure the impact of installation, there are many things that we can track. We can track installation availability, at which point the browser is offering the user the installation, if the promotional infobar or banner is actually presented to the user, the launcher icon install rates, also app assets install rates. So we can know on how many users are actually installing the app asset with the service worker. Remember that not every metric is currently available on every platform. There is something that we cannot track. We cannot track an installation that's currently not available today in the PWA space. So let's see how to track metrics. So to track metrics, you can use your own custom code or SDKs, such as the one from Google Analytics. For example, if you're using Google Analytics, you can create a function with the name track that we receive an action and a value, and you're going to send that action with that value to GA, Google Analytics. We're going to start the Tracking Launcher Icon Installation on Chromium‑based browsers, that includes Google Chrome, Opera, Microsoft Edge, Brave, and other browsers. First, we are going to see how to detect installation availability, at which point the browser is actually offering the user installation. For that we're going to use an event over the window object known as beforeinstallprompt. If that event is being fired, it means that installation is currently available. Beforeinstallprompt event was originally part of the Web App Manifest spec, but because it was only implemented by Chromium, it was removed from the standard and supported only on Chromium‑based browsers. The event is fired when the current URL passes the PWA criteria. Every browser can have a different criteria, but basically typically it is HTTPS, plus a service worker registration, with a fetch event handler, and the Web App Manifest with the right values. Also, the PWA should not be already installed, because if it's already installed, the event is not going to be fired. Installation availability will actually render the infobar or the banner, it will add the badge in the browser, it will create the desktop menu item with the word Install, and it will also allow the developer to provide a custom install button. There are always available installation menu items that can be tracked. For example, all the browsers on Android, iOS, and iPadOS will offer Add to Homescreen, that means we cannot track when that menu is available, because it's always available. Something similar happens on Microsoft Edge on desktop. There is always an option that will let us install the site of an app that is also similar on Chrome on desktop with the name Create Shortcut. So users can always install the app from these menu items, even if on Beforeinstallprompt event wasn't fired. To detect installation, so that means the user has just installed the app, we have also a new event, appinstalled. If that event is fired, then it means most of the time that the PWA was installed on Chromium‑based browsers. The appinstalled event was also part of the Web App Manifest spec, and it's now only implemented by Chromium‑based browsers. It's going to re‑fire when the user has accepted the native installation dialog, from the menu item, from the badge, from the infobar, or from a custom UI element, Let's see the installation flow in Chromium. When the beforeinstallprompt event is fired, many things can happen. If the user clicks on any of these items, a native dialog will appear. On a mobile device, typically we see the Add to the Home Screen there, and on the desktop we typically see Install. If the user is installing the app in Android 4 to Android 7, for example, with Microsoft Edge, and the user is clicking on Install, then the appinstalled event will be fired, and immediately the shortcut will be placed in the home screen. What happens from Android 8 and shortcuts? In this case, when the user clicks on Install, the appinstalled event will be fired; however, a second dialog will appear on the screen. The user has to select where to install the icon or click Add Automatically. If the user touches and holds the icon or clicks on Add Automatically, the shortcut will be placed in the home screen. However, if the user clicks on Cancel on that second dialog, nothing will be installed, but we have appinstalled event fire anyway. So this is like a false‑positive. It's possible to receive a tracking event for an installation and then the installation didn't happen. Another option is Android with WebAPK that, to be honest, is the most common scenario on Android when using Google Chrome. In that case, when the user installs the app, the event will be fired immediately, but the WebAPK mint server in the cloud will actually build and compile the PWA launcher. That takes some time. If everything goes correctly, then the APK will be downloaded and silently installed. But if there is a problem minting that WebAPK, the browser will fall back to a home screen shortcut. The final flow that we have here is on desktop. In this case, the user will accept the installation, the appinstalled event will be fired, and the PWA launcher will be generated and installed locally. It also takes some seconds, and after that, the browser's tab will be closed, and navigation will continue in the PWA scope with all of your JavaScript context, the current URL, and everything that you're seeing in the browser, but in the standalone PWA scope. All these tracking methods are not available on Safari or Firefox. If users are installing the app through an app store, you should look at analytics provided by them, by the app stores, not by JavaScript. What about Tracking Launcher Icon Installation on Safari? It's not possible to detect that operation, but we can make a fair guess using some tricks. Because on iOS and iPadOS a PWA launcher icon has a different storage than Safari for the same origin, so for the same PWA. Local storage, IndexedDB, as well as other storages are different, and PWA is isolated. Because of that, we can have a fair guess of installation, if it's the first time the user is opening the app from the launcher icon. For doing that, we're going to add a script on DOMContentLoaded, so when the page loads, we're going to check if the standalone property is available in the navigator; that means that's Safari on iOS or iPadOS, and we are in standalone mode, then we are going to just check a local storage property such as firstload. If it's undefined, we can have a fair guess that the user has installed the app. And then we're going to set the flag as false for the next load. Some false‑positives can happen if the user has storage pressure. In that case, Safari might also delete the storage of the PWA. Finally, we can track app assets installation using the Cache Storage API that we are typically defining in the service worker. Tracking app asset installation is compatible with all the browsers. In this case, we're going to work in the service worker now. We are going to look at our install event. Typically on the install event, we have a code that opens a cache, and what we have, that cache object, we are adding a list of assets. That addAll method returns a promise. So we can actually track if the assets were installed, or if the asset installation failed using the promise's then and catch events. Just remember, if we want to track uninstallation, it's actually not possible today. Only PWAs that you publish in the app stores can actually track uninstallations. So as a summary, to track installation, we can check the availability using the beforeinstallprompt event, the icon installation through appinstalled event, both in the window object. For assets, we're going to talk about events in the service worker. Remember that false‑positives can occur on appinstalled, mostly because the user wanted to install the app, but something happened after that that canceled the PWA installation. And also remember that most of these events are Chromium‑based only, not available on Safari or Firefox.

# Promote Installation from the User Interface
It's now time to promote installation from the user interface of our PWA. We can create a custom install promotion with a button, with a little banner that we can run there in the contents of our HTML, or even as a menu item in our user interface. To do that, we're going to use the beforeinstallprompt event that we covered before, and that means this technique is Chromium based only. So we need to wait for the event to have the feature available in our app. Typically, we're going to hide the promotion, so the button or the banner, if the user is not in browser display mode. So if the user is using our PWA from the PWA launcher icon, we don't want to promote installation because the app is already installed. Also, if you know the app is installed using an API or other technique, or if you know that an alternative app is installed because maybe the PWA is not installed, but we also have a native app for the same service already installed in that particular OS, if no event is fired, we don't render the promotion or you can have a fallback to manual instructions. So if you click on that install button, it will show you instructions on the screen such as go to the menu and click Add to the Home Screen. We should avoid user experience duplications such as seen and infobar at the bottom from the browser and also seen and install promotion from our user interface. To promote installation through a custom user interface, we're going to listen to the beforeinstallprompt event. The first thing that we're going to do is to preventDefault over the event that we received. That will prevent the banner or an infobar to appear from the browser. It won't prevent a menu item or a bash, but it will prevent infobars. After that, we're going to create a global variable that we're going to use to save the event object that we received in that beforeinstallprompt event. Over our button or menu item or banner, we'll listen to the click event, and we execute the prompt method of that prompt event. But first, we need to check that we actually have a prompt event. If not, we can fallback to instructions. So the prompt function will trigger the native installation dialog. When we are creating our own custom installation dialog prompt, we can detect the result of that prompt. In that case, we're going to take that event. The userChoice object is actually a promise. So we can check when that promise is fulfilled, so when the user has made the choice, and then check the result.outcome. An outcome is a string. It can be accepted or dismissed. So we can track the outcome of that installation dialog that was triggered by our own custom UI button. Just remember, if the app is already installed on desktop or on Android with WebAPK enabled, the event won't be fired. And finally, if you want better debugging, you can go to Chrome flags and enable Bypass user engagement checks. If you enable this, the beforeinstallprompt event is going to be fired on every page load, so you can actually debug better your code.

# Prioritize Store App over Browser Installation
Sometimes you have a PWA in the App Store, or maybe you have a native app in the App Store. In that case, you want to prioritize the store app over the browser installation. So let's see how to do that. Maybe you have a native app that is not a PWA, or a PWA using trusted web activities for Android in the Play Store, or a PWA using a web view on the App Store or Microsoft Store. Typically, the store app can be remembered in the account, so it can appear again if you set up your account in your new phone. Also it can use more features and more ability is granted. But we want to avoid app duplication. We don't one the user to have two apps with the same name in the same device. So if the store app is installed, it's better to avoid installation promotion. If the store up is not installed, then we can select which app to promote. Do we want to promote the browser insulation, or do we want to prioritize the store app? The technologies that we have available to solve the problem are the Installed Related Apps API, the Web App Manifest Related App section, and the Smart App Banners from Apple. We need to know the native app's package ID, typically in the form of the reverse URL, such as com.domain. the name of the app. So if we have an app in the store, we need to get the app's package ID to use all the features that we will see in this video. These techniques don't work with WebAPK on Android. They have a package ID because they are actually Android packages, but it's internal from the Webmin server, and it's not available for the developer. So these techniques are only for the store and not for packages created by your browser. Let's start talking about related apps in the Web App Manifest. In this case, in the Web App Manifest, we can create an array of related applications. It's related_applications in the Web App Manifest file, and this is a collection of different options that we can create in this JSON file. Each object will contain a platform, the platform is basically the store; right now, play is for Google Play Store, windows is for Microsoft Store, and iTunes is for the App Store, but it's currently not used by Safari. Then it will contain the URL as the link of the store pointing to that particular app, the browser will actually open that URL to install the app, and finally, the ID. The ID is actually the package ID of our app. After we have that in the manifest, we can use the Installed Related App's API. It's only available on some Chromium‑based browsers, such as Microsoft Edge or Google Chrome, at least on Android and Windows. In JavaScript, we can getInstalledRelatedApps, that's returning promise, so we can await in an async function, and we're going to receive an array of installed apps. In this case, it will check in the current device if you have one or more of the related apps from the manifest. So this API is taking the value from the app manifest. Typically, we have only one app that we want to check, so we will find that app by its package ID, and if it's there, it means that the app was found, the app is installed in that particular device. If the app on the version that we want is already installed, we should not promote PWA installation from the browser. So we should hide our own custom user interface, or we should prevent the mini‑infobar or the Web App Banner to appear. After we have a related_applications collection, we can define a preference in a flag known as prefer_related_apps. It's false by default, it will express to the browser if we prefer the store app against a PWA installed from the browser. So, if we said true, some browsers will promote in the infobar, or in the badge in the URL bar, the store app, and not the PWA from the browser. On iOS and iPadOS, we have the Smart App Banner, it's only available on Safari on these platforms. It connects a website to a corresponding app in the App Store. So, in our index.html, we can use some meta tags, useful only for iOS and iPadOS. You will see in Safari at the top, the Smart App Banner, promoting the App Store installation. To do that, we need to create the metadata with the name apple‑itunes‑app, and the content will be app‑id= to the package ID of our native application. You can also set arguments, such as a deep link, then the native app can receive that argument, and do something with that. So different routes for different HTMLs in your PWA can point to different app arguments, and from iOS 14, you can use App Clips, so the user can actually run a native application without installing that application. In that case, Safari will render a small app banner, specifying to open the current content from an App Clip. To use this technique, we're still going to use the apple‑itunes‑app meta tag, but for the content, we are going to use the app‑clip‑bundle‑id, and that's another package ID that we have set when we developed our App Clip. So as a summary, if you have apps in the store, PWAs or not, or pure native apps, you can define related apps in the Web App Manifest; you can define your installation preference there, such as if you prefer the app from the store or not; and you can use Smart App Banners for iOS and iPadOS. And you can use the Installed Related Apps API to decide internal promotions in your user interface, and that's how you are going to prioritize an app that you might have in the App Store instead of promoting installation from the browser.

# Improve Installation Reliability  on iOS and iPadOS
We're going to see now how to improve installation reliability. So let's see different techniques to load the web app manifest. Most browsers will download and parse the app manifest when the PWA loads in the tab, in the browser tab. When you go to www.myapp.com, in that case, most browsers will download the web app manifest immediately, but not Safari. Safari loads the app manifest when the user opens the Share menu. Let's say we're in pluralsight.com, and we are doing a search for PWA courses there. In this case, no web app manifest was downloaded, but now we press the share icon. In that case, Safari will load the app manifest and also the icon, and Safari will actually render the share sheet. We can see the icon being downloaded and search the current title in the HTML, not actually the name of the PWA. But if we hit Add to Home Screen, we will finally see the PWA installation dialog taking the icon and also the name of the PWA from the web app manifest. What's the problem? There are some times that the app manifest is not loading, and then we have a problem. The user is trying to install the PWA, but it doesn't work. We are back in our PWA, and remember, no manifest was actually being downloaded from the network, but when we click the share, we have a problem on our connection or in the server. So maybe we are offline or maybe now our LTE connection is not working properly. So then, Safari can't load the manifest or the icon. What will happen is that instead of the icon, you will see a screenshot of the current page. And also, if you press back to the home screen, the screenshot will be used. The full URL will be used, in this case, PWA search in Pluralsight, and the title of the HTML will be used for the icon. So, this is a problem. If there is a network issue or the manifest takes more than a couple of seconds to load, Safari will fall back to a browser shortcut with no manifest at all. If that happens, the icon will be just a screenshot, and the link of that icon will point to the current URL and not the start_url. So it's not going to be the home page of our PWA, but the current route that you have on the screen. So the solution is to preload the app manifest and icons for Safari. So when we load the page, we want to make sure that Safari will have the manifest and the icon later. Maybe we think that we can use the preload link element. In fact, it accepts a manifest like this, or for the icon, we can take the apple‑touch‑icon and also make an image preload. This is actually good solution. The problem is that Safari ignores as="manifest", and it will download the icon. It will ignore this preloaded icon when installing the PWA. So, Safari's not supporting this technique yet. So we're going to ignore the solution, and we're going to create a hack. So to preload the app manifest first, for Safari, we're going to use the Fetch API and data URI. This is a hack that will actually solve the problem. We're going to fetch the manifest, so this will actually download the manifest from the network, and we're going to extract the text, and the text will appear as our manifest variable. After that, we're going to use the DOM API to get the link with the rel=manifest, and we're going to create the data URI pointing to the contents of the manifest. So we are actually inlining the manifest. So we are using the network to download the manifest and inline that text inside the HTML. It doesn't look pretty, I know. That's why it's a hack, but it works. But we don't want to do this for every browser, only for Safari. So in that case, we can actually wrap all of these into that if that will check if the standalone property is available in the navigator option. And that's, today, only targeting Safari. Because the manifest is now embedded in the HTML, when we are adding this to the home screen, the manifest is always there. And we can do something similar for the icon. But in this case, the icon is binary, so we need to convert it into Base64, so we have one more step. We're going to fetch the icon, and we're going to take blob, the binary version of it. And when we have the blob, we're going to read that file as a data URL. So we're going to convert that into a data URL. And finally, when it's done, we're going to take the rel=apple‑touch‑icon and take the result of that read operation. So that code will download the PNG file that we have, we'll convert that into Base64, and we'll inline that in the HTML, only for Safari. Finally, we need to be very careful with deprecated Safari meta tags. And for deprecated meta tags, I'm talking about the apple‑mobile‑web‑app‑capable meta tag. That was the way to create home screen web apps or PWAs before the web app manifest was supported. This is a meta tag that goes in the index.html. When we have that meta tag there, if the web app manifest is not loaded and the meta tag is present, Safari will install a standalone experience, so a PWA, but pointing to the current URL and not the start_url. Also, no scope is defined, so the navigation will have problems within that icon. So be very careful. Even in some versions of iOS and iPadOS, a different web rendering engine is used when the meta tag is present. So, do not insert that deprecated meta tag in your HTML if you're using the web app manifest. There is no reason to actually keep that meta tag there, so be careful with that. So as a summary, to improve iOS and iPadOS installation, we need to preload and inline the web app manifest. We need to preload and inline Apple's icon, and we should not use deprecated meta tags, at least the apple‑mobile‑web‑app‑capable meta tag.

Summary
That's the end of this module. We've seen several techniques for installing the application, starting with the installation architecture review, including different types of installation such as the app launcher icon installation and the app assets installation. We've seen different types, shortcuts, auto generative PWA launchers, and developer generative PWA launchers. We covered how to track installation for analytics, including the beforeinstallprompt and app installed events available in Chromium browsers and other techniques. We've seen how to promote installation from our own user interface using beforeinstallprompt, how to prioritize the store app over the browser installation in case we have our PWA published in the store through different techniques such as trusted web activities on Google Play. And finally, we saw how to improve installation and reliability for iOS and iPadOS because when the user is installing the PWA, there may be a connection issue, and if that happens, the installed icon will have a lot of problems, so we covered how we can preload and inline the web app manifest and the icon for iOS and iPadOS. It's time, now, for the next module, and we're going to manage the app's lifecycle.

# Managing App's Lifecycle

[Managing App's Lifecycle](https://github.com/supernover/Advanced-progressive-web-apps/tree/main/advanced-progressive-web-apps/03) Tutorial

Introduction
It's now time to manage the app's lifecycle. We're going to understand how PWAs work in mobile and desktop operating systems while in the foreground and while in the background. We'll talk about the page visibility and the page lifecycle APIs. We will understand how we can track usage for analytics, such as how many users are actually using the PWA from the icon from the stand‑alone experience versus the browser mode. We're going to improve initial loading performance through navigation preload. We're going to discuss web push notifications to execute code in the background and notify the user, even if the user is not actually using the PWA. And finally, we will talk about different abilities that we have for background execution, background sync, background fetch, and background periodic sync.. So let's start talking about the lifecycle.

### Understand the Lifecycle
As web developers, we are used to the lifecycle of our website within the browser. It's now time to understand what happens when we upgrade the experience to an app. Why do we need to understand the lifecycle? First, to improve user experience because it's not the same as working in the browsers tab. Also, to save resources. That means saving power or memory usage that will help the BIOS' health. Also, because sometimes we should stop timers and pending requests when, for example, our app is not visible on the screen. That's suitable for games, but also for apps. When we are in an operating system, we have a lot of apps. We typically think that all the apps that are opened are actually in memory and executing some code. Typically, one app is actually active or in focus. The rest of the apps might be visible or not, but they're not the actual app that we are using, and that app can also be a PWA. On single‑page applications, only one page navigation instance will exist. So in terms of the lifecycle of your page like DOMContentLoaded, you will have only one HTML, one lifecycle. So in that case, that active PWA will have only one‑page navigation. Because it's a single‑page application, every link that you have within that PWA will be rendered inside the same page navigation. So no new DOMContentLoaded event will be fired. And when you switch to another app, PWA or not, your single‑page PWA and the page navigation now will be in the background. Also, we can have multi‑page applications. In that case, each navigation will have its own page navigation and lifecycle. That is when you have different HTMLs, and when you change the section, you're just pointing to another HTML document. In this case, when we are switching between screens within our PWA, what will happen is that the next page will be a new page navigation within the same PWA. This is like loading another HTML in the same browsers tab. And, of course, if you go back, you go back to the previous page navigation. The app lifecycle is different on desktop or on mobile. Also, different mobile devices can have small differences between each other. For example, on the desktop operating system today, the active app is running, but also the background apps might be running as well. So every app that is open in a desktop operating system has execution rights. When you change your app using, for example, Alt+Tab, the previous app is still running, even if it's not visible. Now, in mobile operating systems, you have one active app, and the other apps that you see in the multi‑task manager are actually paused. That means they might be in memory, but they don't have execution rights by default. They are suspended. When you switch to another app, the previous app is also stopped or suspended. On most of the mobile operating systems, the available RAM is limited. The OS can terminate one of the suspended apps. In that case, the app will still appear in the multi‑task manager, but it's actually not in memory anymore, and that will happen with a lot of apps after several minutes of using your phone. There are a lot of apps in your task manager on Android iOS or iPadOS that are not even in memory anymore. What you're seeing is just a screenshot. When we are talking about PWAs, we might have an active PWA with an active page navigation. We might have a suspended PWA with a suspended page navigation because it's in the background. And also we can have a terminated PWA that will appear in the multi‑task manager. What you see there is just on a static screenshot. If you go back to that terminated PWA, it will start from scratch. On a mobile operating system, there are a couple of exceptions to the one active app rule, and that's split views. On iPadOS, also an Android, you can open more than one app at the same time. In this case, we might have two active apps running at the same time. And all the other apps that you have open during that session are still paused or suspended. So on desktop operating systems, Windows, macOS, Linux, and Chrome OS, all PWAs that are opened, being, then, visible or not, are in memory and they have execution rights. But PWAs that are not visible or are not in focus right now, the OS may limit timers such as set interval or set timeout so they can limit the frequency. And in some rare situations, they can also suspend these PWAs, but it's not common these days. On mobile, Android, iOS, and IPadOS, all PWAs that are visible on the screen, typically one, are in memory and, of course, they have execution rights. And all the PWAs in the background that you're not actually using at that moment could have their page navigations in memory or not. They may still be memory, or they may be already terminated, but they don't have any execution rights. Some exceptions apply here when we are talking about background execution, but by default, if you're not using a PWA on a mobile device, the PWA is not executing any code. However, we do have a service worker on a PWA, and the service worker can have some execution rights while the PWA is not active. That's how background execution works. Their relatives to execute code in the background are APIs on top of the main service worker spec. That means most of these APIs are, today, available only on Chromium‑based browsers such as Google Chrome or Microsoft Edge. That, for example, web push, this one is also available on Firefox, Background Sync, Periodic Background Sync, and Background Fetch. Some of these APIs will require users permission, and we will cover them later in this module.

### Page Visibility and Page Lifecycle APIs
Now it's time to look at APIs. For that, we are going to cover the Page Visibility and the Page Lifecycle APIs. Let's start seeing what happens when you switch from a PWA to another app, or if you go to the desktop or the home screen of your device. On desktop, typically, we are in the situation of switching from a running app to another running app that was in the background. The PWA was still in memory and running, and there are two events available to recognize these situations, visibilitychange and blur. All these events are happening on the window option. On mobile devices and some rare desktop situations, our PWA will go to a suspended state. To detect that situation, we can still use the visibilitychange event and also a new event available on Chromium‑based browsers known as freeze. So now that our PWA is in suspended state, so not executing any code, we need to remember that at any time it can be discarded from memory. It can be terminated by the OS. Now let's see what happens when we're going back to that PWA using the task manager or gesture. On desktop, we know that we are passing again from a running app to another running app, so when the OS makes visible the PWA, we can listen for visibilitychange or focus. In mobile devices, when we are going back to the PWA but it's actually still in memory, so it's in suspended state, it wasn't terminated. We can listen for visibilitychange or the new resume event that is available in Chromium. And if you're going back to the PWA that was discarded from memory, so it's terminated, what will happen is that the Page Lifecycle will start from scratch as if you were opening the PWA from the icon for the first time. On Chromium‑based browsers, we can check a flag on the document object with the name wasDiscarded. If it's true, that means that our page navigation was terminated by the OS, and in that case we can restore the previous state manually if we want. On desktop, PWAs work like browser's tabs. On mobile, if you swipe out the PWA from the multi task manager, so you delete or close the app, the page navigation will disappear in case it was still in memory. Let's see how to detect visibility change that will respond to several situations, such as going from a running app to a suspended app, to a suspended app to a running app or active running to inactive running app. We need to listen for visibilitychange within the window. In that event, we are going to check the visibilityState of the document. If it's hidden, it means that now your PWA is not active. If it's a mobile device, after the execution of this event handler your app will be suspended. If it's not hidden, it can be visible, and that means you're going back to that app, and this is the Page Visibility API. The visibilitychange event, when the state is hidden, is the last chance to save the current state of the app in case we want to restore that state later and improve the user experience. Now it's time to talk about the Page Lifecycle API available on some Chromium browsers. We can detect the app state change using this API, starting with the freeze event. In this case, the freeze event will be used to detect when you're passing from a running PWA to a suspended PWA. We can save the current app's state in the local storage, such as IndexedDB. To detect when you're passing from a suspended PWA to a running PWA, we use resume. In this case, there is no need to restore the state. Why? Because the app was still in memory. That's why it's being resumed. All your navigation context, as well as the JavaScript context, including your variables and objects are still in memory, and the PWA is just defreezing. But what happens if you're going back to the PWA that was terminated? In that case, we can handle the DOMContentLoaded event and check for the wasDiscarded property on the document option, and in this case we can restore the state of our app if we want to. On multi‑page applications, each navigation should register events, changing page will also trigger similar events, so be careful, for example, visibilitychange can be fired when you're changing pages. So the freeze and resume events might not be available on mobile devices. You can save the state on visibilitychange. Remember that visibilitychange will be fired both when you're getting out and in a PWA. You can include a timestamp in the data that you're saving. When should you restore that state? When the page loads. You can use the saved timestamp to decide if you want to restore the state or if you want to start a new navigation. For example, you save the state of your app, and within 5 minutes, if the user is going back to the PWA, but the PWA start from scratch, you restore that state because you feel it's like the same session. But if one week has passed from one load to the other, you probably want to start from scratch. That's a product decision, and it will be different on every app. So as a wrap‑up for these APIs. On desktop, the PWA lifecycle is similar to a browser's tab. On mobile, a PWA in the background is typically suspended, so it's not executing any code, and sometimes it's even discarded from memory, so when you're going back to it, it will start from scratch. We need to think about timers, pending requests, and other situations when the navigation resumes. Do we want to start from scratch or do we want to restore the previous state? For all the browsers, you can use the Page Visibility API to know what's going on and make decisions about the lifecycle, and for Chromium‑based browsers, in some situations you can also use the Page Lifecycle API with the freeze and resume events.

### Track Usage for Analytics
When you publish a PWA, you probably want to know how many users are using it and how they're using it. So we're going to track usage for analytics. We are going to measure impact of a PWA usage using different techniques. We're going to see if the PWA loads from the launcher icon or from the browser as a normal website and also if users are moving from a browser's tab to the standalone PWA and vice versa. Not every metric is available on every platform. Let's start talking about how to track app launcher usage. Different techniques are available to track when the user is accessing our PWA from the launcher icon and not from the browser. We have two techniques available. The first technique is to check a media query matching the manifest's display value when the page loads. In this case, in our JavaScript file, we're going to listen, for example, for the DOMContentLoaded event, and we're going to use that matchMedia API to check a media query. Display‑mode standalone will give you true when the user is using the PWA from the launcher icon in case your manifest's display property is standalone. Remember, it can also be minimal‑ui, fullscreen, and we can also use the same technique to know if the user is in the browser instead of in a PWA mode. The second technique is to specify a tracking argument in the manifest's start_url. So now we are in the manifest file, and we need to look at the start_url property. Instead of pointing to one specific page without arguments, we can add an argument, for example a Google Analytics argument. But you can use your own argument and read that argument server side or client side. There are use cases like using share target, a shortcut, or deep links that can start a standalone navigation in our PWA, but not coming from the launcher icon. You might want to track those situations as well. If you are distributing your app through an app store, you should add a tracking argument in the URL. Techniques are different if you're using trusted web activity for the Google Play Store, a web view for all the stores, or, if you are submitting manually, a URL. Just add the argument to the URL on each situation. Now it's time to track display mode transfer. This is typically on desktop because on desktop you can transfer the current navigation context from the browser's tab to and from the standalone PWA experience. If you are in a browser, such as Google Chrome or Microsoft Edge on desktop, and you are browsing the URL of an already‑installed PWA, you have a way in the menu or in the URL bar to open that URL, the current navigation, in the PWA context. If you do that, then the PWA appears, and the PWA menu has a way to transfer that navigation back to the browser. If you want to track that movement, we can go back to the matchMedia API. For example, we can query about the display‑mode standalone. But instead of doing that once, we are going to register and listen. So every time display‑mode changes from or to a standalone, we want to do something. In that case, if it's true, that means that you're going from the browser to a standalone. And if it's false, you're going from a standalone to browser. Remember, on desktop, we can also have minimal‑ui. If you are using display minimal‑ui in your web app manifest, you should use that value here. On Android, navigation transfer between browser and PWA context is not available. New navigations are always triggered. On iOS and iPad OS, all navigations in the PWA context will start on start_url. Safari doesn't transfer navigation between the PWA scope or the home screen web app and Safari.

### Improve Performance with Navigation Preload
Performance is one of the most important abilities of a PWA. So in this video, we're going to talk about navigation preload. When we are starting a PWA without navigation preload, that is currently a situation for most PWAs, we have a client‑side and a web server. When you open a PWA from the launcher icon, the web runtime starts, then the service worker starts, and the service worker checks in the cache storage if the main HTML, or the start URL, is actually stored. If it's there, it's going to serve the page to the web runtime from the cache storage. And if it's not there, it will store an HTTPS request to the web server. What's the problem? On some slow CPU devices, all these processes can take up to 500 ms, half a second. And we are talking about that particular moment when the service worker decides to go and grab the page from the server, we have a delay that goes between 20 ms to 500 ms. And in the meantime, the user didn't see anything on the screen because we are loading the first HTML. If the page is not in the cache then, or if we know for sure that we're not expecting it to be there, we have a performance penalty because we are using a service worker. We know that without a service worker, we just go to the network. That's why we have navigation preload. It allows the web rendering engine to start the initial navigation request to the server while starting a service worker at the same time. So, when we have navigation preload enabled and we open the PWA from the launcher icon, the web rendering engine requests the page from the server. At the same time, you would start the service worker. And that process, including checking the cache storage, is the one that can take up to half a second. If the service worker decides that it needs to make a request, it can just reuse the request that was started by the web runtime and serve that page so it can be rendered on the screen. So we are requesting the page with no delay from the PWA launch. Navigation preload is available only on some browsers, starting with Google Chrome. And you should enable it only when you know there is a good chance of needing the HTML from the server. The first step is to go to the service worker JavaScript file, and we're going to listen for the activate event. In this event, we're going to create an async function. We are going to check if the navigationPreload property is available, and if it's available, we are going to enable navigation preload through self.registration.navigationPreload.enable. This is promise based, so that's why we are awaiting for it, and we are using an async function. The second step, after you enable navigation preload, is to use the preloaded response in case it's available. In the service worker, we are going to change our fetch event handler. A normal fetch handler typically responds with an async function. We start looking into the cache. If the current request is available in the cache, then we are going to return the response coming from the cache. And if not, typically we are returning a fetch operation, so we are going to the network because it's not in a cache. To use the preloaded response, we need to add something in the middle. We are going to call event.preloadResponse. And if we do have that object, we are going to return it. So now we have three possibilities. The current request is in the cache. The request is not in the cache, but the web rendering engine already started a preload navigation request, so we're going to use it. And the last option, a navigation preload is not available, so we're going to fetch the file from the network. If you enable navigation preload, you must use the response from it. If not, we might end up duplicating requests, so you will go to the network twice for the same file. The request goes to the server with a header in case you want to return something different from the server when it's a navigation preload. For that, you should check for Service‑Worker‑Navigation‑Preload: true.

### Notify the User in the Background with Web Push
It's time to start talking about background execution and how to notify the user in the background using Web Push. With user's permission, the web app can send messages from the server not matter if the PWA is active or not. To use Web Push notifications, the PWA should start asking for permission to send notification to the user. If granted, now the service worker can create a notification from the background. That notification can be created locally at any time, but also the PWA can now subscribe the user to Push, and that will let our server send messages at any moment, even if you are not using the app. In that case, a push event will be fired in the service worker to handle a push. Web Push notifications is actually available on Firefox, Chrome, Edge, Samsung Internet, as well as other browsers. In terms of Safari, it's not available at the time of shooting this video on iOS or iPad OS. Safari on macOS has Web Push notifications, but it's not using the standard spec, so it's not going to be covered in this video. To use notifications, the first step is to ask for notification permissions. Please don't do this when the page loads. You should follow design patterns to create a good user experience and increase the opportunity of getting a granted permission. To ask for permission, we are going to check if the notification object is available, and then we are going to verify if the permission wasn't already granted. To request the permission to the user, we are going to call Notification.requestPermission. That will return a promise, so we're going to await for it, and we're going to receive a string as a result. It can be granted, denied, or default. Let's review the architecture of Web Push. We have our client, mobile phone, a desktop computer, a web server that we own, and a push server. The push server is owned by the browser. So we have a push server from Mozilla for Firefox, a push server from Microsoft for Edge, and a different push server for Google Chrome. In the client, we have a service worker register and a web runtime. That's the one that is rendering our PWA. After we ask for permission, the web runtime can request push to the push server. The server will return subscription details, and we need to send those details to our web server and store them securely because those details will be needed to notify the user later. To do this operation in JavaScript, we are going to check if Web Push is available, and we are going to take the current service worker registration. Over that registration, we are going to use a PushManager, and we're going to get a subscription. That function needs an object, and that object must have UserVisibleOnly true. This is because silent push notifications are not available today on the web. We'll get subscription, we'll return a promise, so we are waiting for it. And if the push data has something, it means it worked, and we should send all that data to our server. The details that we are getting from the push server looks like this. It's a JSON file with an endpoint. The endpoint is a unique ID for that user that represents that user in that browser, and then we also have keys that we have to use later to encrypt messages that we are going to send to that server. So that's why we need to save this data securely in our web server in a database. And if the user is logged in and we want to send custom messages per user, we should assign these details to that particular user. The next step is to send the message. Typically, that happens in the web server. Our web server decides that it needs to send a message to one particular user. So it will take their subscription details and a payload. The payload is the body of the message that we want to send. Typically, we have around 2KB of data that we can send in that payload. We encrypt that message and send that message to the push server. All this process is out of the scope of this video. The push server will actually send a push message to that particular user's web runtime. That web runtime will wake up the service worker even if the user is not using the browser or the PWA at all. And the service worker will finally render a notification on the screen. That step has to be done in our serviceworker file. So we're going to see how to receive the push and create the notification. We're going to listen for the push event. Inside event, we're going to execute the code that will show a notification. A notification has a title and a lot off options, such as the body and the icon. In this case, for the body of the message, we are using the data that is coming from the event, so the data that is coming from the server. There are many other options available to customize the notification. Remember that push messages can arrive when a PWA is active or when it's closed. You are not forced to notify the user with the payload's body, but you are forced to notify something. So we need to create a notification when the push event fires. Typically, we take the payload data and create a notification with that information.

### Background Execution:  Sync, Fetch and Periodic Sync
Now it's time to see other options that we have to execute code in the background. We're going to see sync, fetch, and periodic sync. Let's start with Background Sync. Without user's permission the web app can mark sync operations to do in a background thread even if the user closes the PWA. Background Sync. The first sync action, such as sending data to the server or downloading data from a server until the device has a stable connection to the server. A sync event will be fired in the service worker to handle a pending sync immediately if the network is stable or later when the network goes back to stable. Typically, the battery should be in good level. So if the user is running out of battery, the OS might defer that sync operation for later. In a Background Sync operation, we access the network and fulfill the sync only with pending for the future. Remember, execution happens in the background; maybe no PWA's page is currently loaded. So if you want to notify the user, web notifications is your only option. The first step is to register a Background Sync action. We do that in the service worker context or in the window option as normal JavaScript code. We check if SyncManager is available, that means the API is available, and if it's available, we get the current serviceWorker registration, and we register a sync with a tag‑name. The tag‑name is just a string, so we can have several tags flagged as sync‑pending operations. The second and final step is to handle the sync action in the service worker. In this case, it's just a sync event listener. Typically here we're going to check the tag to see if it's the operation that we're expecting, and in that case, we're going to wait until some syncOperation happens. And that should be a promise. If you fulfill the promise, that tag‑name will be marked as done. If the promise is rejected, it will still be pending, and it will be executed again later. Remember, this sync event will be fired in the background when the connection is stable. Now let's talk about Periodic Background Sync. In this case, the web app can execute code periodically in the background, such us once per day or once per hour. The PWA then can ask to periodically execute code in the background. If granted, a periodicsync event will be fired in the service worker on a synchronization time interval and if the battery and network conditions are met. Typically, we access the network on each execution, but it's not mandatory. Remember, execution happens in the background. Chrome is using a Site Engagement Score to determine if a Periodic Background Sync can happen. If the user is never using the app, the periodicsync event won't happen many times. So even if a website is asking for executing code every hour, that might not happen if the Site Engagement Score defined by Chrome for that particular _____ is not good enough. The first step is to ask for permission. To do that, we're going to use the permissions API, navigator.permission.query, and we're going to ask for periodic‑background‑sync. In return, we're going to receive the state granted or denied. The second step is to register a Background Sync operation. We can have more than one through a tag and the sync interval in milliseconds. So we're going to take the current service worker's registration. And over that, we are going to use periodicSync.register, a tag name, such as Daily News, to download news every morning, and minInterval in milliseconds, for example, that number should express once per day. Typically, we should check if the API is available in the current browser. And, also, we're going to have a try‑catch in case it's not working. The third and final step is to handle that sync operation in the service worker. For that, we use a similar technique, as with Background Sync, with a different event name, periodicsync. If it's the tag that we're expecting, we're going to do that sync operation. The final API that we have available to execute code in the background is Background Fetch. With Background Fetch, the web app can still download files and large content even when the user gets out of the PWA. So the PWA will ask the web engine to make some fetch download the request. Today, it's not available for uploads, but it might be available in the future. The browser then will download the requests in the background while showing an OS notification about the process. Events will be fired in the service worker when the download finishes if the user has clicked the notification in the operating system and also on abort or failure in case there was a problem downloading one or all of the files. The first step is to start the Background Fetch request. The download operation will be handled entirely by the browser. We're going to use the serviceWorker registration. We're going to make a request over the fetch function in the backgroundFetch option. Fetch needs a couple of arguments, such as a name, an array of URLs. They can be HTMLs, images, MP3s, videos, anything. And then an option's object with metadata that is typically going to be used for the notification, such as a title so the user can see what are we actually downloading, icons, and the total amount of bytes that we're expecting to download. We also want to check if Background Fetch API is available. The second step is to handle these events in the service worker. Remember, we don't need to download the files. That's going to be done by the engine. So in the serviceworker.js file, we can listen for different events, such as backgroundfetchsuccess, that will be fired when all the requested files are ready to use, and the files will be available in event.registration. They are actually available in a cache. We can take those files and parse them, or we can take those files and save them in the cache. Also, we can listen for backgroundfetchclick in case the user has clicked in the notification that appears while the files are being downloaded. In this case, you have the option to use clients.openWindow and, in this case, open a URL within your PWA. And if you want to do something when the fetch failed, you can listen for backgroundfetchfailure. If you want to debug background execution in service worker, you can go to DevTools in chromium‑based browsers, inside Application, Service Workers, you will find a whole section to test, for example, push, sync, and periodic sync. And if you want to see what's going on on these APIs, you can also go to Application, Background Services. You have several options there for Background Fetch, Sync, Notifications, Periodic Background Sync, and Push Messaging.

#### Summary
That's the end of this module. We've seen how to manage the app's lifecycle. We now understand the PWA lifecycle, what happens if we have PWA on the screen, what happens if we have a PWA minimized or in the background. We have been using the page visibility APIs and the page lifecycle APIs to improve user experience. We have tracked usage for analytics so we know how to detect if the user is using our PWA from the browser or from the launcher icon. We have also improved performance on the PWA launch with navigation preload. And then we understood how to send messages from the server using web push notifications APIs. To finish covering different techniques available to execute code in the background for a PWA, we have covered background sync to send or receive simple data from and to the network, when the network is stable, background fetch to download large files in the background, and periodic sync that will let us execute some code periodically in the background, such as once per hour or once per day. So that's all for the PWA lifecycle. The next step is to talk about updating the application.

# Updating the Application

[Updating the Application](https://github.com/supernover/Advanced-progressive-web-apps/tree/main/advanced-progressive-web-apps/04)
### Introduction
It's time to talk about updating the application. In this module, we're going to start understanding updates in your Progressive Web App. We're going to see how to update assets and builds, also how to update the App Launcher Metadata, how to alert the user that there is something new in your app using app badges, and finally, we will talk about the app storage, such as what happens with the assets of our PWA if there is no more space in the device. So let's start understanding how we can update a PWA.

### Understand PWA's updates
Let's understand PWA's updates. When we have a native app, the native app is actually in the App Store, and from the App Store, we install the bundle. The bundle includes all the files and assets needed for that particular app. After that, the bundle is installed in our device. But what happens when you update the app in the App Store? You still have an old bundle client side. Using manual or automatic updates, the new bundle will be downloaded and installed again that will replace the old bundle. In this case, native apps must have a version number, 1.0, 2.0, 2.5. You update all the package again when there is a new version. So you download again all the files. When we are talking about PWAs, the developer is in full control of how to cache and serve the resources of the PWA using the service worker and how to manage API calls. We've seen before that we have two installation steps for a PWA, the launcher icon and the app's assets. The same happens when we are updating the app. We can update the launcher icon, and we can update the app assets. PWAs are not forced to a version number, and several update design patterns are actually available. Let's see some of them. Every project can have a different technique. One design pattern is to use full update. In this case, we version all the apps as with native apps. And every time there is a new version, we update all the files. Another technique is partial update. In this case, we version the PWA with delta changes, and we update only the changes. Changes can be files, so we update only the files that have changed. You can also update parts of the file. This is the most common scenario when you have a build system such as the Angular CLI, Create React App, or using _____ Workbook JS. Another design pattern is continuous update. In this case, we version and update assets independently. So we don't have a version number for the app itself. Every time we make a change in CSS, the app will download just that CSS. We have two methods to actually detect when there is a PWA update. We have some automatic detection systems in place and also manual detections. Another decision that we need to make when we are defining our update policy is how notifications to the user will work. So when we detect that there is an update to the PWA, we can ask the user if she wants to install the app at this moment or defer that for later. We can silently update the app without notifying the user, or we can also notify after, so we download the assets, we update the PWA, and we notify the user after we changed the app that she's now in a new version. Finally, we also need to decide how we are going to update the assets. We can do a hot swap, so if we detect that there is a change, we change the file, even if the user is actually using the PWA, and we swap the old file with a new file while the app is actually running. We also have next load cold swap. In this case, we update the assets, but we are going to use the new assets only when the user is using the PWA again in the future, not in the current session. The current session would still be working with the old version. The final option is known as background cold swap. In this case, we detect that there is an update in the background when the user is not using the PWA, and we are swapping the assets in the background as well. So next time the user is open in the app, the app is already updated.

### Update Assets and Builds
Now it's time to talk about how to update assets and builds. A PWA will contain HTML and CSS, images, web fonts, resources, they can be videos, documents, JSON files, JavaScript, that's actually the output of a Web App build in case you're using a framework, and also a service worker JavaScript file. Let's start talking about all the static files that are not the service worker. We will talk about the service worker later. When we have a Progressive Web App, we have a user's device with a service worker and a local cache. Typically, that local cache has some or all the resources of our PWA, and we are trying to clone the server's file system. On that architecture, what happens if we have a new build and that new build has a new JavaScript file? We need to find a way to detect in the service worker that that file has changed an app they define. So the next time we are opening the app, the runtime will take the new version of that JavaScript file. The problem is that that operation is not so simple, so how to detect update in the assets? The Service Worker API has no way to detect changes in individual resources in the server, so we need to analyze all the update patterns that we have, and see how to solve that from a service worker's point of view. If you're doing a full update, typically we're going to version the service worker or the PWA through a configuration file, but most of the time it's the service worker itself. We change the service worker, the browser will download the new service worker, and the new service worker will delete the previous cache and download all the new assets from scratch. If you are going with a partial update design pattern, we version every file in an asset's manifest file for that progressive web app. So every time we make a change in our PWA server side, we update a manifest file. If you want to go with the continuous update design pattern, typically you're going to use the stale‑while‑revalidate pattern in your service worker. In this case, you will be updating each file independently every time you have connection. The next question is when to detect the change. If we need to check if there is an update in PWA assets, when are we going to do that? For example, if you're going with the asset's manifest design pattern, we will have a JSON file with metadata in the server. The service worker can download that file, and it can realize that the JavaScript file is outdated, so it will just download that file. So that's one solution, but the question here is, when are we going to fire that check? The first option that we have is when the service worker starts, so every time there is a new instance of the service worker, you go and check that manifest file. Another option is you have a menu item in the UI that will force the check. If you're using Web Push, you can also use a push message in the background to let the service worker check for updates. And finally, you can use Background Periodic Sync to periodically check if there is a new version, such as once per day. If you decide to make a hot swap, so changing the assets on the fly while the user is using the app, have in mind possible issues with dependencies and different versions of the same resource in memory, because the user has loaded the PWA with an old version of the assets, and from the hot swap moment, new assets request will bring the new version of the assets.

### Update the Service Worker
Now it's time to talk about what happens when we update the service worker. That can also be part of our build system. The browser manages updating the service worker registration automatically, so we don't need to do this manually as with the rest of the assets. The service worker's update algorithm is managed automatically by the browser. It might differ also per browser. But typically, the algorithm will check for an update on every new navigation to a PWA, so every time you start a PWA. Also, it will do that every time there is a background event fired in your service worker, such as a push, a sync, or a periodic sync once every 24 hours. So if you receive 10 push messages in the same day, the browser typically will check for new versions of the service worker only once. On some browsers, also the service worker's registration has an update method. So you can actually force an update check. To request that update check, you take the registration and you just call update. Because this is not available in every browser, at the time of doing this video, the update method, it's not available on Safari, we are going to check if the update function is actually available. You call to the update method, or the browser triggers an automatic update. In those cases, the browser will download the service worker files again. If there is an error downloading the files, nothing will happen. So there will be no update, and the old version of the service worker will still be there up and running. This happens, for example, if you're offline. If you open a PWA and you're offline, there is no way to download the new service worker to check if there is an update. Well, nothing will happen. If the browser could download the files, it will do a byte‑to‑byte comparison with the version that is currently registered. So it will compare the old one with the new one. If there are no differences, nothing will happen. But if it finds that one byte has changed, then an update will be triggered. A typical question that arises at this point is what happens with the HTTP cache? So into the HTTP cache, the browser cache used for the service worker. Some browsers ignore the HTTP headers that defines service worker's file cache policy. For example, your server returns the service worker with a cache policy of 6 hours. Some browsers would just ignore that, and it will download the file anyway from the server. Some other browsers will use the 6‑hour policy with a maximum of 24 hours. So if you set a cache policy of a year for the service worker file, the browser will check again on the next day anyway. This is the update algorithm policy for dependencies because the service worker can have dependencies on other files. For example at the left, we see our service worker registration, and on the right, the contents of that service worker. And that file can actually import other files, such as sw‑events, sw‑fetch, or sw‑push.js. So now we know that the Javascript serviceworker file depends on other files as well. We know that if we change the main service worker file, an update is triggered. But what happens if we don't change the main file, but we change one of the dependencies? Well, fortunately for us, an update is also triggered. However, the HTTP headers defining cache policies for those dependencies might be a problem. By default, the HTTP cache won't be used for the serviceworker main file, sw.js in our case. But the HTTP cache will be used for dependencies when it's checking update. If one of the three dependencies is cached in the browser when the browser is trying to check if there is an update, it will use the cache and notify in the server. Fortunately for us, we have a way to change that default setting. That's a new property that you can add in your registration, updateViaCache. If you use imports, that's the default value, so it will be the same. But we can also say updateViaCache all. In this case, the HTTP cache will be used for the service worker and dependencies. If you change a file on your server, the browser might not take that new version immediately because it's using the browser's cache. But if you say none, in this case, the HTTP cache won't be used for the service worker file or for any of the dependencies. Every time the browser is checking for an update, it will download the service worker file and all its dependencies from the server not matter the browser's cache. What happens after a service worker is updated? Typically, it's stays in waiting state until the next PWA usage makes it active. If you want, you can make the new service worker be the active one as soon as possible. In this case, in the serviceworker.js file in the install event, you call skipWaiting. In this case, the new service worker will start immediately. Finally, let's see how to detect when a service worker's update happens. In a service worker, the install event is enough signal. But what happens in the user interface? In our JavaScript, we can actually check when a service worker's update was installed. For that, we take the registration object, and we listen for updatefound. In this case, updatefound is triggered when the browser knows that there is an update, but the updates are sent already, so we actually need to get the new service worker registration object and listen for a state change event. We need to wait for that new update to be installed. And the state change that we are looking for is installed, and that means the update was found, and that update is currently installed. In the case the new service worker is calling skipWaiting, we can also detect when the new service worker is now activated and controlling our PWA. We'll listen for an event over navigator.serviceWorker controllerchange. In this case, that means that your navigation is currently controlled by a new service worker. So as a summary. there are no silver bullets here for updating the app. There are many design patterns. And we need to define our custom update policy. Service workers update will be managed automatically by the browser, but that don't happens with assets and resources. An asset's updates will need manual management. You can update all the assets with a new service worker, or you can create an assets manifest and update files in groups. The final option is you just use stale‑while‑revalidate pattern. Then, you can update your assets silently, or you can ask the user doing a hot swap or a cold swap in the foreground or in the background. These are all the options available.

### Update App Launcher Meta Data
We know that updating the PWA is not only for assets; we also have the launcher icon. So let's see how to update the app launcher metadata. Maybe you want to update and change the app's name, the array of icons available for the app, the URL, because we are changing the start URL, or you want to add or change a tracking argument, you may also change colors in case you're changing your brand's theme, you can add or remove app shortcuts, or other metadata available. We need to remember that we can distribute our PWA from the browser, from an enterprise distribution system, or from an app store. If you want to update the app launcher for enterprise and app stores, you need to rebuild your PWA launcher. In this case, you will upload it to the store or to the distribution method with a new version number as a native app, because we need to remember that the PWA launcher is a native shell. We need to wait for the store to approve that update, and then for your user to get the new version from the app store or the enterprise system. But what happens if you want to update the app launcher for browser‑installed PWAs? All new users installing the PWA will get that new version. What will happen with installed PWAs? Users that already have that app installed. It depends on the platform and the browser that users are using. On iOS and iPadOS, a re‑install will be needed, so the launcher won't be updated. Those icons sitting in the homescreen won't change, ever. On Android, it's based on the app launcher type, such as WebAPK for shortcuts. And on desktop, typically, re‑install is also needed like on iOS and iPadOS, but some browsers are working in the future to regenerate that package automatically. Let's talk about Android, because it's the place where today update might happen. Let's start talking about Google Chrome using WebAPK. In this case, every new day that you open the PWA, the browser downloads the app manifest and compare properties' values from the current manifest. If there is an update in at least one property, the WebAPK will be marked as needing the update. So the user is still using the installed version, not the new version, but there will be a flag in the browser saying, this PWA will need an update later. After you've closed the app, Chrome will request a new WebAPK to the mint server. Closing the app means that the app will not be in memory anymore. And Chrome will install the new PWA silently, when the device is plugged into power and on WiFi. On Samsung Internet using WebAPK, we also have a similar situation. The browser will check web app manifest updates when you open the PWA. If there is a change, the WebAPK will be updated on WiFi in the next 24 hours. If you're using other browsers, or even Google Chrome with shortcuts, so not with WebAPK, re‑installation is needed, and the launcher won't update automatically. In the case the manifest can be retrieved, and the WebAPK can be generated a couple of times, Chrome will move to a minimum 30‑day period to check for updates again. So, for example, if you remove your PWA from the server, like the server is returning 404, or the origin doesn't exist anymore, Chrome won't check for updates every day. It will try a couple of days, and after a while, it will say, okay, we are moving to a 30‑day period, because for some reason we cannot access the manifest anymore. If you want to debug WebAPK generation on Google Chrome, you can go to chrome://webapks and something similar happens on Samsung Internet, only when you're on a Samsung device. You go to internet://webapks. You will find every WebAPK that is installed on that device with the current scope, manifest's URL, and you will see the Last Update Check Time, If Check for Updates Less Frequently, this is when the 30‑day period is enabled, and also there is a button to actually force the WebAPK update at that moment. Finally, if you change the manifest's URL from your HTML, or if you remove the manifest reference, the installed PWA is considered obsolete, and it won't be updated in the future. Be careful. You shouldn't change the manifest's URL from the HTML.

### Alert the User with App Badging

Let's see how to alert the user that something is new or pending in the app with app badging. What is a app badging? For example, on Windows in the task bar, your icon can contain a badge, for example, that 76 number you see there. On macOS, you can also badge the icon in the dock or in the launch pad. Finally, on Android, typically, what you can see is a little notification dot specifying that there is something new on that particular app. Samsung, Microsoft, and other Android vendors can also use on Android a similar number that we see on macOS or Windows. So let's introduce the Web Badging API. It lets us alert the user that there is new content or pending tasks in our app. It's not yet an official standard. It's currently available in Google Chrome and Microsoft Edge, on Android, Windows, and macOS. Typically, you're going to update the badge number when you're using the PWA, so the PWA's actually active and running. Using periodic sync, every once in a while, we can check if there is more content. If there is more content available or some news or messages to the user, we update the badge. Or when a push message is received, you can actually receive in the payload of the push message the number to show in the badge. To define a new badge for the app's icon, it's actually very simple. It's navigator.setAppBadge with a number inside. We can do this in the page context or in the context of a service worker. Because this is not available in every browser, we should check first if setAppBadge is available in the navigator object. SetAppBadge is promise based, so you can catch the error, for example, and do something different in case you couldn't set the badge. If you want to remove the badge from the icon, you can call clearAppBadge on the same navigator object. The final results that users will see on the icon might be different. For example, showing the number is not actually guaranteed. Setting the badge as 0 will also clear it. It's another way to clear the badge. Platforms are using, for web badging, a best effort scenario, which means they will try to do what you want, but maybe it's not possible. For example, some platforms such as most Android devices don't support batches, but they will use the notification dot instead. So you won't see the number, but a dot. Other platforms such as macOS might crop or display large numbers in different ways. For example, if you're setting 1285 as your number, macOS will show that as 99+, so any number greater than 100 will appear as 99+.

### Manage App's Storage
Now it's time to talk about how to manage the app's storage. The app storage contains the service worker's registration, all the app assets stored in cache storage, and the data that we have stored in web storage such a LocalStorage or IndexedDB. All these storages, today, are under the same quota, and that quota is defined per origin, so per domain. Quota limits are different per browser. For example, in Google Chrome, the limit per origin is actually 60% of the total available disk space. On Firefox, it's 2 GB per origin, and on Safari, it changes per version, but it's roughly 750 MB without any permission, and we can add increments of 200 MB with user's permission. Remember, the quota includes all your assets, the service worker's registration, and IndexerDB. What about the life of that storage? Storage can be defined as best effort, that's the default type, or persistent. On best effort, the browser can clear the storage on storage pressure, so that is when the device is low in storage, it can be the primary memory on mobile phones or the primary hard drive on desktop computers. Also, the browser can clear the storage after some time of inactivity or with user intervention. If the storage is defined as persistent, it will keep all the data unless user intervention happens such as the user is clearing the cache. But persistent storage pressure or time of inactivity won't be enough reasons for the browser to clear the data of our PWA. Let's start talking about progressive web apps on iOS and iPadOS. When these apps are executed within Safari, so in the browser, best effort storage mode is enabled. Eviction, so clearing the data, can happen on storage pressure, after seven days of inactivity, so if the user is not coming back to your PWA in a week, all the data is going to be cleared. A big chunk can also happen if the user goes to Settings, Safari, and Clear the cache. But if the user is actually installing the PWA as a stand‑alone home screen icon, the storage is moved into persistent, and in this case, eviction can happen only if the user goes to Safari settings and clear the data. When you have installed PWA, storage pressure or seven days of inactivity shouldn't be reasons for Safari to delete our data. On Firefox and also Chromium‑based browsers, including Google Chrome, Samsung Internet, and Microsoft Edge, by default, we are also on best effort, and eviction can happen on storage pressure or if the user goes to Settings and clear the cache for that website or for the whole browser. Also, on some of these browsers, when the user is uninstalling the PWA, the browser will offer the option to delete, also, the data at that moment. On these browsers, persistent storage can be requested by an API. If that mode is granted, then eviction can happen only clearing the settings or when the user is uninstalling the PWA. To request persistent storage on Firefox and Chromium, we need to execute navigator.storage.persist. That returns a promise, so we are going to await for it. It will give us a Boolean if persistent storage was granted or not. Firefox will ask the user if persistent storage should be granted, and Chromium will grant or deny based on the criteria. Before using the API, it's always important to check if navigator.storage and navigator.storage.persist are actually available, The same API can be used to ask the current status of persistent storage. For that, we are going to use navigator.storage.persisted. Be careful. In this case, it ends with ed. On some browsers, we can also ask about quota information. For that, we're going to execute navigator.storage.estimate. I'm going to receive an object in return. With that object, we can query the current quota available and the current quota usage, so that's how many bytes are we actually using in our storage. Remember always to check first if the API is available. All the storage APIs return promises, and we are using await. So remember to wrap those calls in an async function. There is no way as of today in the API to disable persistent storage once it was granted. On Chromium‑based browsers, there is a criteria for granting persistent storage. Persistent storage will be granted if it's an installed PWA. So if the user has installed the PWA with WebAPK or shortcuts, Chrome will automatically grant permission. But remember, we must explicitly use the API to have persistent storage. It will also be granted if it's in the bookmarks. If push permission has been granted, we should ask for persistent storage if you're using web push. Finally, if the user has not installed a PWA, but it has high‑site engagement, so that is, the user is using that origin frequently, then persistent storage will also be granted.

### Summary
So we know now how to deal with updating the application. We now understand all the possibilities that we have when we are updating a PWA. We know that the service worker will be abated automatically, but with our own assets we should create our own protocol. It can be using a state where we validate, updating all the assets at once, or create a manifest of all the assets and update them in groups. We know that we can notify the user or update the app silently in the background. We've seen how we can use the service worker to update assets and the builds of our app, including the service worker, also how updating the App Launcher metadata works such as what happens if we are changing the icon, the app's name, or the URL in the future. We've seen that mostly on the WebAPK the package will be reinstalled with the new version, but on other situations users should reinstall the app to get the new data. We've seen how to alert the user that there is something new or pending within the PWA using App Badging. And finally, we covered how to manage the app's storage, how to build with the storage pressure, and how to request persistent storage on compatible browsers. Now it's time for our final module. We are going to see how to integrate our PWA with hardware and platforms.

# Integrating with Hardware and Platforms

[Integrating with Hardware and Platforms](https://github.com/supernover/Advanced-progressive-web-apps/tree/main/advanced-progressive-web-apps/05)
Introduction
It's now time to integrate our PWA with the hardware that we have available in our devices and also with the host platform with the OS. We're going to start talking about hardware and sensors APIs and the current availability for PWAs. We're going to see how to integrate our content with the platform using Web Share, how to create app shortcuts so our PWA icon launcher can have contextual menus opening deep links within our PWA, and finally, we're going to see how we can talk with other apps installing the system through URLs.

# Use Hardware and Sensors with APIs
It's time to talk about how to use hardware and sensors with client‑side JavaScript APIs. The API's today can be grouped in three categories. They can be APIs that are stable and multiplatform. We have some stable APIs, but with limited support. And finally, we have experimental APIs. Compatibility on different browsers change frequently, so we are not going to cover full compatibility in this video because it changes with time. I encourage you to check whatwebcando.today to actually verify hardware and platform APIs available per platform. We have some experimental APIs that are currently available for all the users, even if they are experimental. There are some APIs that will require the user to enable that through a setting or a flag in the browser. And there are some experimental APIs using an origin trial. An origin trial is a way that we have to register our origin for a trial, so then our users can use that API without enabling any flag. Because we are talking about APIs for hardware and sensors, we need to talk about the Google's Fugu capabilities project. The goal of this project is to expose all capabilities of native platforms to the web, while maintaining user security, privacy, and trust. So it's a vision that Google has to add with time all the abilities and APIs that we have on the native side. The full capabilities project starts identifying missing capabilities on the web. They create an initial draft of the spec, so how the API might look like, they gather feedback from the community, then they initiate an origin trial. So if you want to try that API on your website, you can register with your origin, and based on feedback, they will create a formal spec to present to the standards or iterate changing the API. If the formal spec was created, the API will immediately be launched in Google Chrome in stable. Other Chromium‑based browsers might follow as well in the short term. You can check the current status of these APIs at web.dev/fugu‑status. Now it's time to talk about the stable on multi‑platform APIs. So they work everywhere. It's safe for us to use them. We have the Geolocation API. It will let us acquire, use this location, through GPS, WiFi, or other systems. Touch‑and‑pointer APIs, they will let us recognize multitouch, pressure, and even when we're using a pencil, a pen, or a stylus on some mobile devices. Payment request, it will let us access things like Apple Pay or Android Wallet, as well as other payment systems from the OS. Web Authentication will let us authenticate the user using a hardware key, Face ID, Touch ID, or fingertip recognition on some other devices. Media Capture, also known as getUserMedia, to access the raw camera feed, web audio to generate audio on the fly, speech synthesis to make our PWAs speak for us. The Clipboard API. OTP access, that's one‑time password and has to do with SMS when you're registering to a PWA and they are violating your phone number, sending you an SMS, now we have a way to actually grab that number automatically. The Gamepad API so we can access gamepad and joysticks that are connected to the device. Fullscreen and Picture‑in‑Picture APIs, mostly useful for video. Device Orientation and Motion to access some sensors such as accelerometer, gyroscope, and magnetometer. And finally, Web Share. These are the current stable and multi‑platform APIs available on every browser. What about some APIs that are stable, but they have limited support? And to be honest, most of that limited support means Google Chrome or other Chromium browsers. So some of these APIs might not be available on Safari or Firefox. Let's start talking about Web Bluetooth. It will let us connect to Bluetooth low‑energy devices. WebUSB, where a PWA can connect to any handler USB device, so you connect some hardware through USB, but you don't have a driver managing that hardware yet. Well, a website can actually handle that. Ambient Light to actually measure the current light in the environment. User Idle to know if the user is actually using the PWA or not. Advanced camera controls such as work with zoom, focus, and other advanced controls over the camera. Media Recorder that can let you, for example, record the screen. Shape Detection. Today, it's stable for bar codes and for text detection such as doing OCR. Vibration API, Battery Status API, and Device Memory to know about available memory in that device. We continue talking about stable APIs, but with limited support. We have Native File System to actually read and write from the file system. A Contact Picker. Speech Recognition to actually open the microphone and recognize what the user is saying. WebXR. That's an API that will let us do VR, virtual reality, and also AR, augmented reality, with a magic window that is using your phone or using a headset. Screen Orientation Lock. Wake Lock that will keep the screen awake while you're using the PWA. The Presentation API to work with multi‑screens. The ability to run the PWA on a startup or different multi‑screen APIs useful for full levels and external monitors. If an API is stable on one platform, that doesn't mean there is a formal standard defined yet. And just to mention some of the experimental APIs that we can play with, we have face recognition over an image field. We can recognize where the face is, where the eyes are, the nose, and the mouth. Web Serial tracks the serial hardware connected to your computer. Web Near Field Communication. Content Indexing that will let us define content that we have in our PWA, even if we are offline, so then the OS or an assistant or the browser can expose that information to the user. WebHID, human interface device, to access with the same API to different interfaces that we can use to interact with the device. A Media Picker, useful to grab a photo or a video from the gallery. Tabbed App Support for desktop PWAs. WebCodecs will let us ship our own video or audio codec. Virtual Keyboard API to deal with the virtual keyboard that we have on mobile devices, WebGPU, and Web MIDI. These are all experimentally APIs that we can play with. If we are distributing our PWA on App Stores, we may be able also to bridge to native APIs. And in that case, we can use native code such as Swift on iOS, iPadOS, on macOS, Codely on Android, or .NET on Windows and call that code from JavaScript, but only for App Stores. When you see APIs, remember the P in PWA. P stands for progressive, and that's for progressive enhancement. So, we should always check if an API is there or not before using it and offer alternatives in case the API's not there.

# Integrate Content with Web Share
We're going to see how to integrate our content with Web Share. Web Share is an API, but we'll let our PWA interact with the share mechanism available within the OS. It's currently available on Safari, for iOS and iPadOS, including PWAs, on Chromium‑based browsers, typically on Android, and on some compatible desktop operating systems with a shared dialogue. And the idea is that you will be able to share from your PWA to other apps, text, a URL, so a link, and also files. It can be an image or a PDF. The target of that share operation can be, for example, Copy to Clipboard, other apps, PWA or not, AirDrop, in the case of Apple devices that will let you, for example, send that data to another device, or even Save to File. So the user will be able to actually download that content that we are sharing as a file. To use the API, we just need to access navigator.share. Navigator.share receives an object as an argument. For example, we can set a title that we want to share. In this case, we are just going to share text. This is useful to copy the text or to let the user move that text into another document such us a Google Doc, a Microsoft Word, or a notes application. Because the API may not be available everywhere, we should check if share is available in the navigator object. Share returns a promise, so we can actually check the result of that share operation. On the then we are going to know that the share worked. And the catch, we can do something when the share was canceled or when the share operation had the problem. Of course, you can also use async/await. If you want to share a link, you can add a URL to your option. And also, you can specify a title and a text. When you specify both title and text most of the systems today will just use the text. So have that in mind when you are setting both. The text property will be used instead of the title property, but there may be some apps using both. If you want to share the current URL, you can just use for the URL window.location.href, What if you want to share files to other apps? Well in this case, we are going to use navigator.share, we need to set a title, and then we need to send an array of fileObject. And to share a file we need to check that that version of the API is available. Instead of verifying if share is available, we're going to use canShare. CanShare is a function that we can use sending some arguments and it will verify if the browser is able to share those arguments. So in this case we can actually check if we can share those files before actually trying to share them. So the API is actually pretty simple. Web Share has a companion. It's a different aspect known as Web Share Target. It works today only on Chromium‑based browsers, typically on Android. If you use this, your PWA can receive data shared from other apps. So instead of sending data from our app, we are going to receive data from other apps. We can receive text and URLs. The simplest version of this API will let our PWA receive a navigation to a URL that we define with all the shared data, the text and the URL, in the QueryString arguments. But the spec also allows us to receive POST requests. This is useful to receive complex data that will change our app and also to receive files. The Web Share Target API, it's actually based on the web app manifest. To receive basic data, so text and/or links, we're going to add a new key in our web app manifest of share_target. We are going to be a target for a share. We need to define the URL that we want the web rendering engine to open when we receive a share. The method, we're going to use GET for simple data And then we're going to set an object that will map keys from the original app to keys in our query string. So, for example, if we say "title": "title" it means it will take the title from the share object that we received and it will send that title in a title QueryString argument. We are going to typically use JavaScript to read these arguments and do something with it. If you want to receive complex data that can change our PWA's content, for example we are going to save that data. The data can be JSON or it can be text. We're going to use the same key in the manifest, the URL that will receive the data, probably a different URL, and then we are going to use POST as the method. Because this is POST, we cannot use JavaScript to read the data, but we can use the FetchEvent handler in the service worker if we want to handle these client side. We need to specify the encoding type. In this typically we are going to use a multipart/form‑data format. And then we are going to map the data to the form data that we will receive. Finally, to receive files we are also going to use the same key in the manifest. Typically, if we want to process this client side, we can use, again, the service worker to do that. If not, we are going to receive the files in the server. We are going to use POST as the method, the same encoding type, and then in the params argument we are going to define an array of file types that we accept. Per type we can define an array of extensions and MIME types. For example in this case we are receiving PNG images that can be .png files or they can be content with the MIME type image/png. We want content matching the MIME type image/png or files with the .png extension. Remember that files is an array so we can define more than one collection here. All the files will be received by the same action by the same URL. Only one share_target declaration is accepted in the app manifest. So if you want to receive text, URLs, and/or files you need to express that as one URL only. And then, based on the arguments, you can redirect the user to different routes or you can do different actions. The host OS, so for example Android, will use the apps name and the icons from the manifest for the shared dialogue. We can now define different icons for the shared dialog that will be the same icons that we have for our PWA.

# Create App Shortcuts
One way that we have to integrate with some operating systems is to create app shortcuts. App shortcuts are menu items that will appear on the icon launcher's contextual menu, that is right‑clicking on desktop or long pressing the icon on mobile devices. Each menu item will open a navigation within the PWA, but to a different URL, different from the start URL. Menu items are currently defined statically per app. Changing these items requires changing the app manifest. This is how app shortcuts looks like on Windows on the left and an Android on the right. You can see the PWA icon contains several items when you right‑click or long press. App shortcuts is currently available in Chromium on Android and Windows. That's, for example, Google Chrome and Microsoft Edge, and we're going to define that in the web manifest. So in the JSON file, we're going to add a new entry key, it's shortcuts. That's an array of object, it's object is a shortcut, will contain a name, a short name, a description, the URL that we want to open when that menu item is triggered, and an array of icons. The most important properties here are short name, URL, and at least one icon. Same rule applies to these properties at the top‑level properties of the same name.

# Talk with Other Apps through URLs
It's now time to talk with other apps through URLs. On the modern operating system, an installed app can capture links coming from other apps before they are rendered in a browser. We call this link capturing. It lets us communicate between apps in the OS. We have three ways to do this. Universal links. It's just a normal standard web URL, such as https://firt.dev. A custom URI. That is a way to identify one specific app with a custom protocol, such as a Skype column. And finally, on Android. we also have available intents. An Android intent will let us communicate with other apps using action and arguments. When we are talking about linking to other apps, we are just talking about normal anchor elements, such as a href. We can also use forms, and the URL will go in the action, or JavaScript, changing location.href. So we're going to define different URLs that will open other apps. On most situations, data flows one way only, from our PWA to other apps. We cannot expect a response in return. Let's start with universal links. This is for installed apps that are capturing their own websites' URLs. If the app is not installed, the website will appear, so we have a fallback. The URL can be a deep link pointing to one specific document in that website. On the Google side, Google Maps, YouTube, Google Drive, and the Play Store are supporting universal links, which means if you link your one specific YouTube video, the YouTube app will render that instead of the browser. On Apple, Maps, Apple News, the App Store, iTunes, and Apple Music are using universal links, as well as Office and the Store in the Microsoft site. If you're talking about the Facebook group apps, Instagram post, Facebook post or groups, Messenger links to profiles, and WhatsApp links, such as for a group, will open in their native apps instead of the browser, if they are installed. Other apps using universal links includes Twitter, Pinterest, TikTok, and many others. Now let's jump into the custom URI scheme. In this case, it's going to be used for installed apps that are capturing custom protocols. If the app is not installed, an error will appear. Unfortunately, there is no API available to check if it will work before actually using it. On Android, many apps can listen to the same protocol. In that case, the user will see a chooser dialog. We can pass arguments through the query string. For example, it's protocol: an action name, question mark, and a group of arguments in the query string. Remember always to encode your argument values for URLs. Let's start seeing some examples of multiplatform URI schemes. They work on iOS, Android, iPadOS, and desktops, if there are apps installed for that particular function. We're going to start with tel, t‑e‑l. In this case, it's for making a phone call. We should use international format, such as +1 for US, Canada, and other countries, +34 for Spain, or +54 for Argentina. That's because we don't know where the user is currently located, so we always need to use an international number. SMS will let you send a text message, and you can express an optional body. The message is not sent automatically, but the SMS app will be open, and it will be prepopulated with that data. The user has to finally hit send from that app. The classic mailto protocol will let us open the default email app and create a new email for us. The body can contain HTML that is compatible with some clients. Remember to URL encode that argument. The WhatsApp app also has a custom protocol. You can send a WhatsApp message, and the text and number are optional. If you send the text, but not the number, it will open a chat selector so you can pick where do you want to send the text. If you send the number but not the text, it will open the chat without prepopulating a chat message. Skype has also a custom URI protocol on all the platforms. If you use a Skype call on the user, it will open the user's profile. You're going to start a call adding ?call with an optional video Boolean property that you can use to directly start a video call. Some browsers, such as Brave and Firefox, will let you also open URLs in that particular browser, even if they're not the default browsers on that OS. You can search the app you want to interact with plus "uri scheme" to see if there is any documentation. For example, skype uri scheme. Now let's see some specific URI schemes that are working only on iOS and iPadOS. For example, Google Chrome. If you want to open Google Chrome for iOS, you use googlechromes and then the URL. It will open Google Chrome, replacing HTTPS with googlechromes. Something similar happens with Apple News. And if you want to open an app in the App Store, you can use the itms‑apps custom protocol with a URL, and the final part of the path is the ID of the app you want to open. If you want to FaceTime, you're going to start out all your call using facetime‑audio and then the phone number or the email of the user. Or just facetime to start a video call. Apple Maps will accept maps: and the URL accepts the same arguments than Google Maps, including driving directions. You can open settings through the prefs: custom protocol starting in the root, or you can go to one specific section of settings, such as SAFARI. And finally, you can run the shortcut with a name with the shortcuts: protocol and the action run‑shortcut. These are just examples. There are many other URI schemes available. Remember to use specific Apple‑related URI schemes only when you know for sure that you are on that platform. The final option that we have here is Android intents. This is only for Android browsers, and it lets us map a native Android intent call to a URL. We can open specific apps by ID or make generic calls, such as, I have this PDF, I want to open a PDF editor, but I don't know which app is doing that. For that, we are going to use the intent: protocol with a lot of arguments, starting with an Optional host, a hard‑coded #Intent;, and a lot of arguments semicolon separated. These arguments are coming from Android intents. There is a final argument that we can express, S.browser_fallback_url, where we can express a URL that will be used in case the Android intent cannot be fulfilled. And finally, we need to add end; to finish the URL. Everything should be in just one line. For example, if we want to open the native Pluralsight app in Android, we can use intent:#Intent;package=, the name of the package, ;end. And if we want, we can also add the fallback URL in case the app is actually not installed. Remember to execute the intent: protocol only on Android and to check Android's native intent documentation for further information. Now what about our PWA registering a URL so other apps can talk to us? That's known as Link Capturing for PWAs. There is no way to register a custom protocol today for PWAs, but with WebAPK on Android, any URL pointing to our manifest scope will be handled by our PWA as a Universal Link. So our installed PWA will be capturing its own URL within the Android system. Unfortunately, we don't have any option to open a PWA from a link on iOS or iPadOS, and on desktop we are not there yet, but some experiments are happening, so we may see Link Capturing for PWAs on desktop soon.

# Conclusion
So we have already seen how to integrate with hardware and platforms, APIs that we have available for hardware and sensors, including stable APIs for different platforms, and stable APIs that works only on some platforms, and some experimental APIs. We have covered how we can share our content with Web Share, and how we can use our PWA to get content from other apps using Web Share Target. We have created app shortcuts to add different navigation links in the contextual menu of our app launcher icon, and finally, how to talk with other apps through URLs using universal links, custom URI schemes, or the Android Intent protocol. And that's the end of our Advanced Progressive Web Apps course. We have seen different techniques while we were installing the app, using the app, updating the app, and integrating the app with the rest of the system. I want to thank you for being with me in this journey of increasing the user experience of our PWAs, and I hope we can continue our conversation on social media. You can find me on Twitter @firt, firt, or you can read more about PWAs in my personal website, firt.dev. Thank you very much, and see you soon.

